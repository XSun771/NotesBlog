---
title: Mutual SSL in Spring With Self-Signed Certificate
date: 2023-05-23 21:44:51
tags: SSL,计算机网络
---

# SSL 知识

## 能够建立彼此信任通讯的数学基石

非对称算法中的密钥对具有这样的特性

（1） 若内容被这对密钥中的密钥A所加密，则只能使用密钥B解密，密钥A自己都不能解密得到原来的内容。反之，密钥B加密的内容也只有密钥A能解密。

（2）不可能使用密钥A推出密钥B。

（3）非对称密钥对有无穷多个且不难生成。

由此，试图通讯的甲乙双方可以自己生产自己的非对称算法密钥对，并毫无顾忌地分享其中一个（这个被分享出去的称为**公钥**）同时谨慎地保管另一个（称为**私钥**）。此时，甲若用乙分享的公钥加密了一段自己刚随便生成没有公开的内容，然后将这个加密公开出去，不考虑无限次尝试，碰巧以及乙私钥泄露的情况，那么只有乙能用自己的私钥解密得到这个内容。进而，谁能告诉乙他之前公开的加密内容所对应的原内容是啥，那么那个人一定是甲。

由此，通讯双方可以确认自己在和谁通信，并且在使用公钥加密的基础上，通信内容也只有对方可以解密。

## 诡计多端的中间人

由上一节我们知道，只要甲和乙已经获知了彼此的公钥，那么甲和乙就可以彼此验明正身，交换只有彼此可知的信息。

但『只要甲和乙已经获知了彼此的公钥』这个条件并不是那么容易确保的。如果有一个中间人丙，它对甲说自己的公钥是乙的公钥，对乙说自己的公钥是甲的公钥。 那么甲就会把丙当做乙，乙也会把丙当做甲。此时甲和乙之间的通讯内容也对丙完全透明了，因为他们加密用的是丙的公钥，自然可以被丙的私钥解密。

怎么避免这样的**中间人攻击**呢？

（1）操作系统都内置一些可信的权威机构的公钥。

（2）不想被中间人顶替自己蒙骗自己的通讯者的那一方，向这些被操作系统默认内置的权威机构中的一个注册自己的公钥和自己的信息，并拿到由那个机构基于它的私钥和信息后加密的结果。

（3）所有通讯的发起者在验明正身的时候，都必须让另一方说明自己是注册在了哪个权威机构。然后用系统内置的那个权威机构的公钥对内容解密，获得其中的公钥。

中间人此时无法拿自己的公钥来伪造这里的公钥，因为：

（1）中间人是不可信的违法犯罪者，没有权威机构的私钥，它使用另外一个私钥的加密结果，用正确的公钥解密，解密的结果里的公钥也不可能是他自己的公钥。而且解密出来的其它信息，比如IP信息（或者域名信息）也往往是不可对或者与通讯发起者的目标不一致的，这都会导致通讯发起者认为没有与对的目标建立其绘画

（2）由于非对称加密密钥对的性质，无法基于公钥解密的结果，去反推用公钥加密前的内容应该长什么样。

这里的权威机构就是我们说的 CA (Certificate Authority), 也即**数字证书认证机构**。

## 证书与相关概念

<table>
<tr/>
<td>CA</td> <td>Certificate Authority</td> <td>数字证书认证机构</td> <td></td>
<tr/>
<tr/>
<td>CSR</td> <td>Certificate Signing Request</td> <td>凭证签发请求</td> <td>站点在向全文机构申请证书前准备的自己的资料（包含公钥但不应当包含私钥）。CA 基于 CSR 签发 Cert。</td>
<tr/>
<tr>
<td>Cert</td> <td>Certificate</td> <td>证书</td> <td>一般公钥以及站点的信息已经封装在其中。</td>
</tr>
<tr>
<td>Key</td> <td>Private Key</td> <td>私钥</td> <td>因为公钥一般都封装在证书中，因此在和 Cert 同时出现的语境中，一般就简单地指私钥。比如保存私钥的文件的后缀名便是key。</td>
</tr>
<tr>
<td>KeyStore</td> <td>KeyStore</td> <td>无公认的中文说法</td> <td>一个 KeyStore 中可以存放多组密钥对，或证书私钥对，亦或者不成对的。KeyStore 是对 SSL 资料的打包，将多个 SSL 资料文件合并为一个方便使用。</td>
</tr>
<td>Self-signed CA/Cert</td> <td>Self-signed CA/Cert</td> <td>自签名CA/证书</td> <td>在局域网，比如公司的内网，只要这个局域网的参与者认可的 CA，以及由这个 CA 签发的证书。</td>
</tr>
</table>